import { describe, expect, it } from "@effect/vitest";
import * as Primitive from "../../src/Primitive";
import * as ProxyEnvironment from "../../src/ProxyEnvironment";
import * as OperationPath from "../../src/OperationPath";
import * as Operation from "../../src/Operation";

describe("TreePrimitive", () => {
  // Define node types using the new TreeNode API
  const FileNode = Primitive.TreeNode("file", {
    data: Primitive.Struct({ name: Primitive.String(), size: Primitive.Number() }),
    children: [] as const,
  });

  const FolderNode = Primitive.TreeNode("folder", {
    data: Primitive.Struct({ name: Primitive.String() }),
    children: (): readonly Primitive.AnyTreeNodePrimitive[] => [FolderNode, FileNode],
  });

  const fileSystemTree = Primitive.Tree({
    root: FolderNode,
  });

  // Helper to create a mock environment with state access
  const createEnvWithState = (
    state: Primitive.TreeState<typeof FolderNode> = []
  ): { env: ReturnType<typeof ProxyEnvironment.make>; operations: Operation.Operation<any, any, any>[] } => {
    const operations: Operation.Operation<any, any, any>[] = [];
    let currentState = [...state] as Primitive.TreeState<typeof FolderNode>;
    let idCounter = 0;

    const env = ProxyEnvironment.make({
      onOperation: (op) => {
        operations.push(op);
        // Apply operation to keep state in sync
        currentState = fileSystemTree._internal.applyOperation(currentState, op);
      },
      getState: () => currentState,
      generateId: () => `node-${++idCounter}`,
    });

    return { env, operations };
  };

  describe("schema", () => {
    it("exposes root node type", () => {
      expect(fileSystemTree.root).toBe(FolderNode);
      expect(fileSystemTree.root.type).toBe("folder");
    });

    it("required() returns a new TreePrimitive", () => {
      const required = fileSystemTree.required();
      expect(required).toBeInstanceOf(Primitive.TreePrimitive);
      expect(required).not.toBe(fileSystemTree);
    });

    it("default() returns a new TreePrimitive with default value", () => {
      const defaultInput = {
        type: "folder" as const,
        id: "root",
        name: "Root",
        children: [],
      };
      const withDefault = fileSystemTree.default(defaultInput);
      const initialState = withDefault._internal.getInitialState();
      expect(initialState).toHaveLength(1);
      expect(initialState![0]!.id).toBe("root");
      expect(initialState![0]!.type).toBe("folder");
      expect(initialState![0]!.data).toEqual({ name: "Root" });
    });
  });

  describe("proxy - basic operations", () => {
    it("get() returns empty array for initial state", () => {
      const { env } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(proxy.get()).toEqual([]);
    });

    it("set() generates tree.set operation with nested input converted to flat", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const nestedInput = {
        type: "folder" as const,
        name: "Root",
        children: [],
      };
      proxy.set(nestedInput);

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("tree.set");
      // The payload should be flat format
      const payload = operations[0]!.payload as Primitive.TreeState<typeof FolderNode>;
      expect(payload).toHaveLength(1);
      expect(payload[0]!.type).toBe("folder");
      expect(payload[0]!.data).toEqual({ name: "Root" });
      expect(payload[0]!.parentId).toBe(null);
      expect(payload[0]!.id).toBe("node-1"); // Generated by env.generateId
    });

    it("root() returns the root node", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "child1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const root = proxy.root();
      expect(root).toBeDefined();
      expect(root!.id).toBe("root");
      expect(root!.parentId).toBe(null);
    });

    it("node() returns a node proxy by ID", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "child1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const node = proxy.node("child1");
      expect(node).toBeDefined();
      expect(node!.id).toBe("child1");
      expect(node!.type).toBe("file");
      expect(node!.get().data).toEqual({ name: "File1", size: 100 });
    });

    it("children() returns ordered children", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "child2", type: "file", parentId: "root", pos: "a1", data: { name: "File2", size: 200 } },
        { id: "child1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const children = proxy.children("root");
      expect(children).toHaveLength(2);
      expect(children[0]!.id).toBe("child1"); // a0 comes first
      expect(children[1]!.id).toBe("child2"); // a1 comes second
    });
  });

  describe("proxy - type narrowing with is() and as()", () => {
    it("is() returns true for matching node type", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const fileProxy = proxy.node("file1");
      expect(fileProxy!.is(FileNode)).toBe(true);
      expect(fileProxy!.is(FolderNode)).toBe(false);

      const folderProxy = proxy.node("root");
      expect(folderProxy!.is(FolderNode)).toBe(true);
      expect(folderProxy!.is(FileNode)).toBe(false);
    });

    it("as() returns typed proxy for correct type", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const fileProxy = proxy.node("file1")!.as(FileNode);
      expect(fileProxy.id).toBe("file1");
      expect(fileProxy.type).toBe("file");

      // Type-safe data access
      fileProxy.data.name.set("UpdatedName");
      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("string.set");
    });

    it("as() throws for wrong type", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "file1", type: "file", parentId: null, pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const nodeProxy = proxy.node("file1");
      expect(() => nodeProxy!.as(FolderNode)).toThrow(Primitive.ValidationError);
    });
  });

  describe("proxy - insert operations with TreeNode types", () => {
    it("insertFirst() creates node at beginning of children", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "existing", type: "file", parentId: "root", pos: "a1", data: { name: "Existing", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      const newId = proxy.insertFirst("root", FileNode, { name: "First", size: 50 });

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("tree.insert");
      expect(newId).toBe("node-1");

      const payload = operations[0]!.payload as { id: string; pos: string; type: string };
      expect(payload.type).toBe("file");
      expect(payload.pos < "a1").toBe(true); // Should be before existing
    });

    it("insertLast() creates node at end of children", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "existing", type: "file", parentId: "root", pos: "a0", data: { name: "Existing", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.insertLast("root", FileNode, { name: "Last", size: 50 });

      const payload = operations[0]!.payload as { pos: string };
      expect(payload.pos > "a0").toBe(true); // Should be after existing
    });

    it("insertFirst() with null parentId creates root node", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.insertFirst(null, FolderNode, { name: "Root" });

      expect(operations).toHaveLength(1);
      const payload = operations[0]!.payload as { parentId: string | null; type: string };
      expect(payload.parentId).toBe(null);
      expect(payload.type).toBe("folder");
    });
  });

  describe("proxy - validation", () => {
    it("throws when inserting invalid child type", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Files cannot have children
      expect(() => proxy.insertFirst("file1", FileNode, { name: "Child", size: 50 })).toThrow(
        Primitive.ValidationError
      );
    });

    it("throws when inserting non-root type at root level", () => {
      const { env } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(() => proxy.insertFirst(null, FileNode, { name: "File", size: 50 })).toThrow(
        Primitive.ValidationError
      );
    });

    it("throws when inserting second root", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(() => proxy.insertFirst(null, FolderNode, { name: "SecondRoot" })).toThrow(
        Primitive.ValidationError
      );
    });
  });

  describe("proxy - toSnapshot()", () => {
    it("returns undefined for empty tree", () => {
      const { env } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(proxy.toSnapshot()).toBeUndefined();
    });

    it("returns nested snapshot with spread data", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
        { id: "folder1", type: "folder", parentId: "root", pos: "a1", data: { name: "Subfolder" } },
        { id: "file2", type: "file", parentId: "folder1", pos: "a0", data: { name: "File2", size: 200 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));


      const snapshot = proxy.toSnapshot();
      expect(snapshot).toBeDefined();
      expect(snapshot!.id).toBe("root");
      expect(snapshot!.type).toBe("folder");
      expect(snapshot!.parentId).toBe(null);
      expect(snapshot!.pos).toBe("a0");
      expect(snapshot!.name).toBe("Root"); // Data spread at node level
      expect(snapshot!.children).toHaveLength(2);

      const file1Snapshot = snapshot!.children[0]!;
      expect(file1Snapshot.id).toBe("file1");
      expect(file1Snapshot.parentId).toBe("root");
      expect(file1Snapshot.pos).toBe("a0");
      expect(file1Snapshot.name).toBe("File1");
      expect(file1Snapshot.children).toEqual([]);

      const folder1Snapshot = snapshot!.children[1]!;
      expect(folder1Snapshot.id).toBe("folder1");
      expect(folder1Snapshot.children).toHaveLength(1);
      expect(folder1Snapshot.children[0]!.name).toBe("File2");
    });
  });

  describe("proxy - at() with typed node", () => {
    it("at() returns typed proxy for node data", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.at("file1", FileNode).name.set("UpdatedName");

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("string.set");
      expect(operations[0]!.path.toTokens()).toEqual(["file1", "name"]);
      expect(operations[0]!.payload).toBe("UpdatedName");
    });

    it("at() throws when node type mismatch", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "file1", type: "file", parentId: null, pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(() => proxy.at("file1", FolderNode)).toThrow(Primitive.ValidationError);
    });
  });

  describe("proxy - move operations", () => {
    it("move() changes parent and position", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "folder1", type: "folder", parentId: "root", pos: "a0", data: { name: "Folder1" } },
        { id: "folder2", type: "folder", parentId: "root", pos: "a1", data: { name: "Folder2" } },
        { id: "file1", type: "file", parentId: "folder1", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Move file1 to folder2
      proxy.move("file1", "folder2", 0);

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("tree.move");
      const payload = operations[0]!.payload as { id: string; parentId: string };
      expect(payload.id).toBe("file1");
      expect(payload.parentId).toBe("folder2");
    });

    it("throws when moving node to its descendant (cycle prevention)", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "folder1", type: "folder", parentId: "root", pos: "a0", data: { name: "Folder1" } },
        { id: "folder2", type: "folder", parentId: "folder1", pos: "a0", data: { name: "Folder2" } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(() => proxy.move("folder1", "folder2", 0)).toThrow(Primitive.ValidationError);
    });
  });

  describe("applyOperation", () => {
    it("tree.set replaces entire tree", () => {
      const newNodes: Primitive.TreeState<typeof FolderNode> = [
        { id: "new-root", type: "folder", parentId: null, pos: "a0", data: { name: "NewRoot" } },
      ];
      const operation: Operation.Operation<any, any, any> = {
        kind: "tree.set",
        path: OperationPath.make(""),
        payload: newNodes,
      };

      const result = fileSystemTree._internal.applyOperation([], operation);
      expect(result).toEqual(newNodes);
    });

    it("tree.insert adds a new node", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
      ];
      const operation: Operation.Operation<any, any, any> = {
        kind: "tree.insert",
        path: OperationPath.make(""),
        payload: {
          id: "file1",
          type: "file",
          parentId: "root",
          pos: "a0",
          data: { name: "File1", size: 100 },
        },
      };

      const result = fileSystemTree._internal.applyOperation(initialState, operation);
      expect(result).toHaveLength(2);
      expect(result[1]).toEqual({
        id: "file1",
        type: "file",
        parentId: "root",
        pos: "a0",
        data: { name: "File1", size: 100 },
      });
    });

    it("tree.remove removes node and descendants", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "folder1", type: "folder", parentId: "root", pos: "a0", data: { name: "Folder1" } },
        { id: "file1", type: "file", parentId: "folder1", pos: "a0", data: { name: "File1", size: 100 } },
        { id: "folder2", type: "folder", parentId: "root", pos: "a1", data: { name: "Folder2" } },
      ];
      const operation: Operation.Operation<any, any, any> = {
        kind: "tree.remove",
        path: OperationPath.make(""),
        payload: { id: "folder1" },
      };

      const result = fileSystemTree._internal.applyOperation(initialState, operation);
      expect(result).toHaveLength(2);
      expect(result.map(n => n.id)).toEqual(["root", "folder2"]);
    });

    it("delegates node data operations", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const operation: Operation.Operation<any, any, any> = {
        kind: "string.set",
        path: OperationPath.make("file1/name"),
        payload: "UpdatedName",
      };

      const result = fileSystemTree._internal.applyOperation(initialState, operation);
      const updatedNode = result.find(n => n.id === "file1");
      expect(updatedNode!.data).toEqual({ name: "UpdatedName", size: 100 });
    });
  });

  describe("getInitialState", () => {
    it("automatically creates a root node when no default is set", () => {
      const initialState = fileSystemTree._internal.getInitialState();
      expect(initialState).toBeDefined();
      expect(initialState).toHaveLength(1);
      expect(initialState![0]).toMatchObject({
        type: "folder",
        parentId: null,
        data: {},
      });
      // Verify ID and pos are generated
      expect(typeof initialState![0]!.id).toBe("string");
      expect(typeof initialState![0]!.pos).toBe("string");
    });

    it("returns the default value when set (converted from nested)", () => {
      const defaultInput = {
        type: "folder" as const,
        id: "root",
        name: "Root",
        children: [],
      };
      const withDefault = fileSystemTree.default(defaultInput);
      const initialState = withDefault._internal.getInitialState();
      expect(initialState).toHaveLength(1);
      expect(initialState![0]!.id).toBe("root");
      expect(initialState![0]!.type).toBe("folder");
      expect(initialState![0]!.parentId).toBe(null);
      expect(initialState![0]!.data).toEqual({ name: "Root" });
    });
  });

  describe("proxy - partial update", () => {
    it("update() on TypedNodeProxy updates only specified fields", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Use the update method via as()
      const fileProxy = proxy.node("file1")!.as(FileNode);
      fileProxy.update({ name: "UpdatedName" });

      // Should generate only a string.set operation for the name field
      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("string.set");
      expect(operations[0]!.path.toTokens()).toEqual(["file1", "name"]);
      expect(operations[0]!.payload).toBe("UpdatedName");
    });

    it("update() preserves other fields when updating partial data", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Update only the size field
      proxy.node("file1")!.as(FileNode).update({ size: 200 });

      // Should generate only a number.set operation for the size field
      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("number.set");
      expect(operations[0]!.path.toTokens()).toEqual(["file1", "size"]);
      expect(operations[0]!.payload).toBe(200);

      // The name should remain unchanged in the state
      const updatedState = proxy.get();
      const file1 = updatedState.find(n => n.id === "file1");
      expect(file1!.data).toEqual({ name: "File1", size: 200 });
    });

    it("update() handles multiple fields at once", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Update both name and size
      proxy.node("file1")!.as(FileNode).update({ name: "NewFile", size: 500 });

      // Should generate two operations
      expect(operations).toHaveLength(2);
      
      // Verify both fields were updated
      const updatedState = proxy.get();
      const file1 = updatedState.find(n => n.id === "file1");
      expect(file1!.data).toEqual({ name: "NewFile", size: 500 });
    });

    it("updateAt() provides convenient partial update by node id", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Use updateAt for convenience
      proxy.updateAt("file1", FileNode, { name: "QuickUpdate" });

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("string.set");
      expect(operations[0]!.path.toTokens()).toEqual(["file1", "name"]);
      expect(operations[0]!.payload).toBe("QuickUpdate");
    });

    it("updateAt() throws for wrong node type", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "file1", type: "file", parentId: null, pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // Trying to update a file node as a folder should throw
      expect(() => proxy.updateAt("file1", FolderNode, { name: "NewName" })).toThrow(
        Primitive.ValidationError
      );
    });

    it("updateAt() throws for non-existent node", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
      ];
      const { env } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(() => proxy.updateAt("nonexistent", FileNode, { name: "Name" })).toThrow(
        Primitive.ValidationError
      );
    });

    it("data.update() on at() proxy also works for partial updates", () => {
      const initialState: Primitive.TreeState<typeof FolderNode> = [
        { id: "root", type: "folder", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "file1", type: "file", parentId: "root", pos: "a0", data: { name: "File1", size: 100 } },
      ];
      const { env, operations } = createEnvWithState(initialState);
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // The at() method returns the data proxy which has update()
      proxy.at("file1", FileNode).update({ size: 999 });

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("number.set");
      expect(operations[0]!.path.toTokens()).toEqual(["file1", "size"]);
    });
  });

  describe("proxy - insert with defaults", () => {
    // Define node types with defaults
    const ItemNodeWithDefaults = Primitive.TreeNode("item", {
      data: Primitive.Struct({ 
        title: Primitive.String().required(), // Must provide
        count: Primitive.Number().default(0), // Has default, optional
        active: Primitive.Boolean().default(true), // Has default, optional
      }),
      children: [] as const,
    });

    const ContainerNodeWithDefaults = Primitive.TreeNode("container", {
      data: Primitive.Struct({ 
        name: Primitive.String().required(), // Must provide
      }),
      children: (): readonly Primitive.AnyTreeNodePrimitive[] => [ContainerNodeWithDefaults, ItemNodeWithDefaults],
    });

    const treeWithDefaults = Primitive.Tree({
      root: ContainerNodeWithDefaults,
    });

    // Helper to create a mock environment
    const createEnvWithDefaultsTree = (
      state: Primitive.TreeState<typeof ContainerNodeWithDefaults> = []
    ): { env: ReturnType<typeof ProxyEnvironment.make>; operations: Operation.Operation<any, any, any>[] } => {
      const operations: Operation.Operation<any, any, any>[] = [];
      let currentState = [...state] as Primitive.TreeState<typeof ContainerNodeWithDefaults>;
      let idCounter = 0;

      const env = ProxyEnvironment.make({
        onOperation: (op) => {
          operations.push(op);
          currentState = treeWithDefaults._internal.applyOperation(currentState, op);
        },
        getState: () => currentState,
        generateId: () => `node-${++idCounter}`,
      });

      return { env, operations };
    };

    it("insertFirst() only requires fields without defaults", () => {
      const initialState: Primitive.TreeState<typeof ContainerNodeWithDefaults> = [
        { id: "root", type: "container", parentId: null, pos: "a0", data: { name: "Root" } },
      ];
      const { env, operations } = createEnvWithDefaultsTree(initialState);
      const proxy = treeWithDefaults._internal.createProxy(env, OperationPath.make(""));

      // Only provide required field 'title', count and active should use defaults
      const newId = proxy.insertFirst("root", ItemNodeWithDefaults, { title: "New Item" });

      expect(operations).toHaveLength(1);
      expect(operations[0]!.kind).toBe("tree.insert");
      expect(newId).toBe("node-1");

      const payload = operations[0]!.payload as { data: { title: string; count: number; active: boolean } };
      expect(payload.data.title).toBe("New Item");
      expect(payload.data.count).toBe(0); // Default value
      expect(payload.data.active).toBe(true); // Default value
    });

    it("insertLast() applies defaults for omitted fields", () => {
      const initialState: Primitive.TreeState<typeof ContainerNodeWithDefaults> = [
        { id: "root", type: "container", parentId: null, pos: "a0", data: { name: "Root" } },
      ];
      const { env, operations } = createEnvWithDefaultsTree(initialState);
      const proxy = treeWithDefaults._internal.createProxy(env, OperationPath.make(""));

      // Provide title and override count, let active use default
      proxy.insertLast("root", ItemNodeWithDefaults, { title: "Item", count: 42 });

      const payload = operations[0]!.payload as { data: { title: string; count: number; active: boolean } };
      expect(payload.data.title).toBe("Item");
      expect(payload.data.count).toBe(42); // Overridden
      expect(payload.data.active).toBe(true); // Default value
    });

    it("insertAt() allows omitting all optional fields with defaults", () => {
      const initialState: Primitive.TreeState<typeof ContainerNodeWithDefaults> = [
        { id: "root", type: "container", parentId: null, pos: "a0", data: { name: "Root" } },
      ];
      const { env, operations } = createEnvWithDefaultsTree(initialState);
      const proxy = treeWithDefaults._internal.createProxy(env, OperationPath.make(""));

      // Only provide required 'name' for container
      proxy.insertAt("root", 0, ContainerNodeWithDefaults, { name: "Subfolder" });

      const payload = operations[0]!.payload as { type: string; data: { name: string } };
      expect(payload.type).toBe("container");
      expect(payload.data.name).toBe("Subfolder");
    });

    it("insertAfter() uses defaults when fields are omitted", () => {
      const initialState: Primitive.TreeState<typeof ContainerNodeWithDefaults> = [
        { id: "root", type: "container", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "item1", type: "item", parentId: "root", pos: "a0", data: { title: "First", count: 1, active: false } },
      ];
      const { env, operations } = createEnvWithDefaultsTree(initialState);
      const proxy = treeWithDefaults._internal.createProxy(env, OperationPath.make(""));

      // Insert after sibling with only required field
      proxy.insertAfter("item1", ItemNodeWithDefaults, { title: "Second" });

      const payload = operations[0]!.payload as { data: { title: string; count: number; active: boolean } };
      expect(payload.data.title).toBe("Second");
      expect(payload.data.count).toBe(0); // Default
      expect(payload.data.active).toBe(true); // Default
    });

    it("insertBefore() uses defaults when fields are omitted", () => {
      const initialState: Primitive.TreeState<typeof ContainerNodeWithDefaults> = [
        { id: "root", type: "container", parentId: null, pos: "a0", data: { name: "Root" } },
        { id: "item1", type: "item", parentId: "root", pos: "a0", data: { title: "First", count: 1, active: false } },
      ];
      const { env, operations } = createEnvWithDefaultsTree(initialState);
      const proxy = treeWithDefaults._internal.createProxy(env, OperationPath.make(""));

      // Insert before sibling with only required field, override active
      proxy.insertBefore("item1", ItemNodeWithDefaults, { title: "Zeroth", active: false });

      const payload = operations[0]!.payload as { data: { title: string; count: number; active: boolean } };
      expect(payload.data.title).toBe("Zeroth");
      expect(payload.data.count).toBe(0); // Default
      expect(payload.data.active).toBe(false); // Overridden
    });
  });
});

describe("TreePrimitive - nested input for set() and default()", () => {
  // Define node types using the new TreeNode API
  // Using TreeNodeSelf for self-referential nodes preserves type safety
  const FileNode = Primitive.TreeNode("file", {
    data: Primitive.Struct({ name: Primitive.String(), size: Primitive.Number().default(0) }),
    children: [] as const,
  });

  const FolderNode = Primitive.TreeNode("folder", {
    data: Primitive.Struct({ name: Primitive.String() }),
    children: [Primitive.TreeNodeSelf, FileNode],
  });

  const fileSystemTree = Primitive.Tree({
    root: FolderNode,
  });

  // Helper to create a mock environment with state access
  const createEnvWithState = (
    state: Primitive.TreeState<typeof FolderNode> = []
  ): { env: ReturnType<typeof ProxyEnvironment.make>; operations: Operation.Operation<any, any, any>[] } => {
    const operations: Operation.Operation<any, any, any>[] = [];
    let currentState = [...state] as Primitive.TreeState<typeof FolderNode>;
    let idCounter = 0;

    const env = ProxyEnvironment.make({
      onOperation: (op) => {
        operations.push(op);
        // Apply operation to keep state in sync
        currentState = fileSystemTree._internal.applyOperation(currentState, op);
      },
      getState: () => currentState,
      generateId: () => `node-${++idCounter}`,
    });

    return { env, operations };
  };

  describe("set() with nested input", () => {
    it("converts nested input to flat TreeState", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.set({
        type: "folder",
        name: "Root",
        children: [
          { type: "file", name: "file1.txt", children: [] },
          { type: "file", name: "file2.txt", children: [] },
        ],
      });

      expect(operations).toHaveLength(1);
      const payload = operations[0]!.payload as Primitive.TreeState<typeof FolderNode>;
      expect(payload).toHaveLength(3);

      // Root
      expect(payload[0]!.type).toBe("folder");
      expect(payload[0]!.parentId).toBe(null);
      expect(payload[0]!.data).toEqual({ name: "Root" });

      // First file child
      expect(payload[1]!.type).toBe("file");
      expect(payload[1]!.parentId).toBe(payload[0]!.id);
      expect(payload[1]!.data).toEqual({ name: "file1.txt", size: 0 }); // size has default

      // Second file child
      expect(payload[2]!.type).toBe("file");
      expect(payload[2]!.parentId).toBe(payload[0]!.id);
      expect(payload[2]!.data).toEqual({ name: "file2.txt", size: 0 });

      // Positions should be in order
      expect(payload[1]!.pos < payload[2]!.pos).toBe(true);
    });

    it("allows explicit IDs in nested input", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.set({
        type: "folder",
        id: "my-root",
        name: "Root",
        children: [
          { type: "file", id: "my-file", name: "file.txt", children: [] },
        ],
      });

      const payload = operations[0]!.payload as Primitive.TreeState<typeof FolderNode>;
      expect(payload[0]!.id).toBe("my-root");
      expect(payload[1]!.id).toBe("my-file");
    });

    it("throws on duplicate IDs", () => {
      const { env } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      expect(() =>
        proxy.set({
          type: "folder",
          id: "dup",
          name: "Root",
          children: [
            { type: "file", id: "dup", name: "file.txt", children: [] },
          ],
        })
      ).toThrow(Primitive.ValidationError);
    });

    it("validates child types against schema", () => {
      const { env } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      // File nodes cannot have children with type "folder"
      // But since we can't test FileNode as root (wrong type), let's test folder with wrong child
      // Actually FolderNode accepts both FolderNode and FileNode, so this won't fail on types
      // Let's test wrong root type instead - but the input is typed, so this is caught at compile time
      // We can test runtime by forcing wrong type
      const invalidInput = {
        type: "file" as "folder", // Cast to bypass type check
        name: "WrongRoot",
        children: [],
      };

      expect(() => proxy.set(invalidInput as any)).toThrow(Primitive.ValidationError);
    });

    it("handles deeply nested structures", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.set({
        type: "folder",
        name: "Root",
        children: [
          {
            type: "folder" as const,
            name: "Level1",
            children: [
              {
                type: "folder",
                name: "Level2",
                children: [
                  { type: "file", name: "deep.txt", children: [] },
                ],
              },
            ],
          },
        ],
      });

      const payload = operations[0]!.payload as Primitive.TreeState<typeof FolderNode>;
      expect(payload).toHaveLength(4);

      // Verify parent chain (cast data to access name since TreeNodeState.data is unknown)
      const root = payload.find(n => (n.data as { name: string }).name === "Root");
      const level1 = payload.find(n => (n.data as { name: string }).name === "Level1");
      const level2 = payload.find(n => (n.data as { name: string }).name === "Level2");
      const deep = payload.find(n => (n.data as { name: string }).name === "deep.txt");

      expect(root!.parentId).toBe(null);
      expect(level1!.parentId).toBe(root!.id);
      expect(level2!.parentId).toBe(level1!.id);
      expect(deep!.parentId).toBe(level2!.id);
    });

    it("applies data defaults to nested input", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.set({
        type: "folder",
        name: "Root",
        children: [
          { type: "file", name: "file.txt", children: [] }, // size omitted, should use default
        ],
      });

      const payload = operations[0]!.payload as Primitive.TreeState<typeof FolderNode>;
      const fileNode = payload.find(n => n.type === "file");
      expect((fileNode!.data as any).size).toBe(0); // Default value
    });
  });

  describe("default() with nested input", () => {
    it("creates initial state from nested default", () => {
      const treeWithDefault = fileSystemTree.default({
        type: "folder",
        id: "default-root",
        name: "Default Root",
        children: [
          { type: "file", id: "default-file", name: "readme.txt", children: [] },
        ],
      });

      const initialState = treeWithDefault._internal.getInitialState();
      expect(initialState).toHaveLength(2);

      const root = initialState!.find(n => n.id === "default-root");
      const file = initialState!.find(n => n.id === "default-file");

      expect(root!.type).toBe("folder");
      expect(root!.parentId).toBe(null);
      expect(root!.data).toEqual({ name: "Default Root" });

      expect(file!.type).toBe("file");
      expect(file!.parentId).toBe("default-root");
      expect((file!.data as any).size).toBe(0); // Default applied
    });

    it("generates IDs for default when not provided", () => {
      const treeWithDefault = fileSystemTree.default({
        type: "folder",
        name: "Root",
        children: [],
      });

      const initialState = treeWithDefault._internal.getInitialState();
      expect(initialState).toHaveLength(1);
      expect(typeof initialState![0]!.id).toBe("string");
      expect(initialState![0]!.id.length).toBeGreaterThan(0);
    });
  });

  describe("sibling ordering", () => {
    it("maintains children order with correct positions", () => {
      const { env, operations } = createEnvWithState();
      const proxy = fileSystemTree._internal.createProxy(env, OperationPath.make(""));

      proxy.set({
        type: "folder",
        name: "Root",
        children: [
          { type: "file", id: "first", name: "a.txt", children: [] },
          { type: "file", id: "second", name: "b.txt", children: [] },
          { type: "file", id: "third", name: "c.txt", children: [] },
        ],
      });

      const payload = operations[0]!.payload as Primitive.TreeState<typeof FolderNode>;
      const first = payload.find(n => n.id === "first")!;
      const second = payload.find(n => n.id === "second")!;
      const third = payload.find(n => n.id === "third")!;

      // Positions should be in ascending order
      expect(first.pos < second.pos).toBe(true);
      expect(second.pos < third.pos).toBe(true);
    });
  });
});

// =============================================================================
// Integration Tests - Tree with Complex Structures
// =============================================================================
